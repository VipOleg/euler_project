import some_functions as sf  # Деякі корисні функції

def first ():
	# ініціалізація пермінних
	result = 0

	for x in range(1000): # Цикил який проходить по всім числом від 0 до 1000
		if x % 3 == 0 or x % 5 == 0 : # Перевірка чи дане число ділиться бещ остачі на 3 або на 5
			result += x # Якщо ділиться то додаєм число до result 

	print(result) # Виводим результат на екран

def second ():
	# ініціалізація пермінних
	result = 0
	num_array = [1, 1] # Це деякі числа порядку фибаначі і минуле його число

	for x in range(4 * 10 ** 6): # Цикил від 0 до 4 000 000 ( Взагалі тут мав буди нескінченний масив на кожній ітерації якого ми маєм змогу получити ноиер ітерації )
		a = x % 2 # перемінна для почергового запису наступного числа ряду фібаначі в праву бо в ліву сторону
		num_array[a] = sum(num_array) # запис числа фібаначі в num_array 

		if num_array[a] % 2 == 0: # Якщо число яке ми тільки що записали без остачі ділиться на 2
			result += num_array[a] # То додаєм його в результат

		if result > 4 * 10 ** 6: # Якщо результат більший за 4 000 000
			break # То виходим з цикла

	print(result) # Виводим результат на екран

def third ():
	# ініціалізація перемінних 
	num = 600851475143 # число задане в задачі
	iteration = 2 # переменна для зменшення кількості перевірок
	i = 2 # перемінна яка позначає кількість ітерацій цикла
	result = 0 # перемінна для результату 

	while i < num / iteration :
		if num % i == 0 : # перевірка чи число ділиться на і без остачі
			iteration = i # відсієння зайвих перевірок
			
			if sf.prime_number_check(i) : # перевірка чи знайдене число просте
				result = i # якщо знайдене число просте то записуємо його в result
			
		i += 1 # збільшуєм значення перемінної i на 1 
		
	print(result) # виводим результат на екран
	
def fourth ():
	pass


def main():
	#first()
	#second()
	third()

if __name__ == '__main__':
	main()